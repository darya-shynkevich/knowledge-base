Some external factors affect the time it takes for a function to run: the speed of the processor, what else the computer is running, etc. So it’s hard to make strong statements about the _exact runtime_ of an algorithm. Instead we use big O notation to express _how quickly its runtime grows_.

# References:

1. [Доступное введение в анализ сложности алгоритмов.](http://discrete.gr/complexity/?ru)
2. [Video no. 1-16](https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O) Abdul Bari's Algorithm Playlist (video)
3. [A Gentle Introduction to Algorithm Complexity Analysis](http://discrete.gr/complexity/)
4. [UC Berkeley Big O (video)](https://archive.org/details/ucberkeley_webcast_VIS4YDpuP98)
5. [UC Berkeley Big Omega (video)](https://archive.org/details/ucberkeley_webcast_ca3e7UVmeUc)
6. [Amortized Analysis (video)](https://www.youtube.com/watch?v=B3SpQZaAZP4&index=10&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN)
7. TopCoder (includes recurrence relations and master theorem):
    1. [Computational Complexity: Section 1](https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/)
    2. [Computational Complexity: Section 2](https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/)
8. [Знай сложности алгоритмов](https://habr.com/ru/post/188010/)
9. [TimeComplexity in Python](https://wiki.python.org/moin/TimeComplexity)
10. [ttps://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)