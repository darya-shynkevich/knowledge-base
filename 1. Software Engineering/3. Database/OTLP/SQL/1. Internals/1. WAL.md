WALs are not just smaller but also need fewer IOs. You have to write out a full sector to disk even if only one bit in it changed. ***WALs are append only*** and ***you only write to the end*** of the file. If you modify 4 rows that data may be in 4 sectors but may only need 1 WAL sector.

And even if you write multiple WAL sectors they are sequential which is faster than doing random IOs. The advantage was massive with spindle drives but even on SSDs it is faster.

> WAL is the source of truth, as we are writing ahead of the data files, we write the changes to data pages in memory of course (for on going transactions to use the latest and greatest) but we delay flushing the data pages to disk because the WAL made it to disk.


# References:

1. ~~[What happens when databases crash?](https://medium.com/@hnasr/what-happens-when-databases-crash-74540fd97ea9)~~
2. [Why databases need Write-ahead log (WAL) — A deep dive](https://medium.com/@hnasr/what-is-wal-write-ahead-log-a-deep-dive-a2bc4dc91170)
3. [Redo, Undo and WAL logs | The Backend Engineering Show](https://www.youtube.com/watch?v=uHvR7nOu5m4&list=PLQnljOFTspQXjD0HOzN7P2tgzu7scWpl2&index=95) (video)
4. [Write-Ahead Log — WAL](https://medium.com/nerd-for-tech/write-ahead-log-wal-c4c3327c6742)
5. [WAL в PostgreSQL: 1. Буферный кеш](https://habr.com/ru/company/postgrespro/blog/458186/)