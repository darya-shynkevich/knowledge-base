

```Python
>>> print(sys.getsizeof(ob)) 240
```

#### 1. Class instance

```Python
class Point:  
    #  
    def __init__(self, x, y, z):  
        self.x = x  
        self.y = y  
        self.z = z  
  
>>> ob = Point(1,2,3)  
>>> x = ob.x  
>>> ob.y = y
```

![[Pasted image 20231205234042.png]]

#### 2. Instance of class with `__slots__`

Существенное уменьшение следа экземпляра в памяти достигается путем исключения `__dict__` и `__weakref__`. Это возможно при помощи "трюка" со `__slots__`:

```Python
class Point:  
    __slots__ = 'x', 'y', 'z'  
  
    def __init__(self, x, y, z):  
        self.x = x  
        self.y = y  
        self.z = z  
  
>>> ob = Point(1,2,3)  
>>> print(sys.getsizeof(ob))  
64
```
![[Pasted image 20231205234258.png]]
Достигается такое сокращение тем, что в памяти после заголовка объекта хранятся ссылки на объекты, а доступ к ним осуществляется при помощи специальных дескрипторов (descriptor), которые находятся в словаре класса:

```Python
>>> pprint(Point.__dict__)  
mappingproxy(  
              ....................................  
              'x': <member 'x' of 'Point' objects>,  
              'y': <member 'y' of 'Point' objects>,  
              'z': <member 'z' of 'Point' objects>})
```

#### 3. Tuple

Для представления наборов данных в Python также есть встроенный тип `tuple`. Tuple это фиксированная структура или запись, но без имен полей. Для доступа к полю используется индекс поля. Поля tuple раз и навсегда связываются с объектами-значениями в момент создания экземпляра tuple:

```Python
>>> ob = (1,2,3)  
>>> x = ob[0]  
>>> ob[1] = y # НЕВОЗМОЖНО
```
![[Pasted image 20231205234450.png]]
#### 4. Namedtuple

```Python
>>> Point = namedtuple('Point', ('x', 'y', 'z'))
```

![[Pasted image 20231205234533.png]]

#### 5. Recordclass: мутируемый namedtuple без GC

В пакете **recordclass** вводится в обиход тип `recordclass.mutabletuple`, который практически во всем идентичен tuple, но также поддерживает присваивания. На его основе создаются подклассы, которые практически во всем идентичны namedtuples, но также поддерживают присваивание новых значений полям (не создавая новых экземпляров). Функция `recordclass` подобно функции `namedtuple` позволяет автоматизировать создание таких классов:

```Python
>> > Point = recordclass('Point', ('x', 'y', 'z'))  
>> > ob = Point(1, 2, 3)
```

Экземпляры класса имеют аналогичную стуктуру, что и `tuple`, но только без `PyGC_Head`:
![[Pasted image 20231205234703.png]]

По умолчанию функция `recordclass` порождает класс, который не участвует в механизме циклической сборки мусора. Обычно `namedtuple` и `recordclass` используют для порождения классов, представляющих записи или простые (нерекурсивные) структуры данных. Корректное их использование в Python не порождает циклических ссылок. По этой причине в следе экземпляров классов, порожденных `recordclass` по умолчанию, исключен фрагмент `PyGC_Head`, который необходим для классов, поддерживающих механизм циклической сборки мусора (более точно: в структуре `PyTypeObject`, соответствующей создаваемому классу в поле `flags` по умолчанию не установлен флаг `Py_TPFLAGS_HAVE_GC`).

#### 6. Dataobject

Другое решение, предложенное в библиотеке `recordclass` основано на идее: использовать структуру хранения в памяти, как у экземпляров классов со `__slots__`, но не участвовать при этом в механизме циклической сборки мусора. Класс порождается при помощи функции `recordclass.make_dataclass`:

```Python
>>> Point = make_dataclass('Point', ('x', 'y', 'z'))
```

Другой способ – использовать объявление класса путем наследования от `recordclass.dataobject`:

```Python
class Point(dataobject):  
    x:int  
    y:int  
    z:int
```

Создаваемые таким образом классы будут порождать экземпляры, которые не участвуют в механизме циклической сборки мусора. Структура экземпляра в памяти такая же, как в случае со `__slots__`, но без заголовка `PyGC_Head`:
![[Pasted image 20231205235049.png]]
Для доступа к полям также используются специальные дескрипторы для доступа к полю по его смещению относительно начала объекта, которые размещены в словаре класса:

```Python
mappingproxy({'__new__': <staticmethod at 0x7f203c4e6be0>,  
              .......................................  
              'x': <recordclass.dataobject.dataslotgetset at 0x7f203c55c690>,  
              'y': <recordclass.dataobject.dataslotgetset at 0x7f203c55c670>,  
              'z': <recordclass.dataobject.dataslotgetset at 0x7f203c55c410>})
```
#### 7. Cython

```Python
cdef class Python:  
    cdef public int x, y, z  
  
 def __init__(self, x, y, z):  
      self.x = x  
      self.y = y  
      self.z = z
```

```Python
>>> ob = Point(1,2,3)  
>>> print(sys.getsizeof(ob))  
32
```
![[Pasted image 20231205235406.png]]
Однако следует помнить, что при доступе из кода на Python всякий раз будет осуществляться преобразование из `int` в объект Python и наоборот.

#### 8. Numpy

Использование многомерных массивов или массивов записей для большого количества данных дает выигрыш в памяти. Однако для эффективной обработки на чистом Python следует использовать методы обработки, ориентированные на применение функций из пакета `numpy`.

```Python
>>> Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])
```

Обычный доступ к элементам массива и строкам потребует преобразования объекта Python в значение C `int` и наоборот. Извлечение одной строки приводит к созданию массива, содержащего единственный элемент. След его уже не будет столь компактен:

```Python
>>> sys.getsizeof(points[0]) 68
```