- We should aim for simplicity because simplicity is a prerequisite for reliability.
- Simple is often erroneously mistaken for easy. "Easy" means "to be at hand", "to be approachable". "Simple" is the opposite of "complex" which means "being intertwined", "being tied together". Simple != easy.
- What matters in software is: does the software do what is supposed to do? Is it of high quality? Can we rely on it? Can problems be fixed along the way? Can requirements change over time? The answers to these questions is what matters in writing software not the look and feel of the experience writing the code or the cultural implications of it.
- The benefits of simplicity are: ease of understanding, ease of change, ease of debugging, flexibility.
- Complex constructs: State, Object, Methods, Syntax, Inheritance, Switch/matching, Vars, Imperative loops, Actors, ORM, Conditionals.
- Simple constructs: Values, Functions, Namespaces, Data, Polymorphism, Managed refs, Set functions, Queues, Declarative data manipulation, Rules, Consistency.
- Build simple systems by: 
    - Abstracting - design by answering questions related to what, who, when, where, why, and how.
    - Choosing constructs that generate simple artifacts.
    - Simplify by encapsulation.

Overengineering can lead to the following problems:
1. Increased complexity: The more complex a system is, the harder it is to maintain, test, and debug.
2. Increased development time: Adding unnecessary features or functionality will take longer to develop and test.
3. Increased maintenance costs: Overengineered systems are harder to maintain, meaning that it will cost more to keep them running.
4. Reduced performance: Overengineered systems may perform worse than simpler systems, due to the increased complexity.

### References:

1. https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.93.8928 TBD
2. https://www.infoq.com/presentations/Simple-Made-Easy/
3. [Why Static Languages Suffer From Complexity](https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html#)
4. [Use Solid Technologies - Don’t Re-invent the Wheel - Keep It Simple!](https://medium.com/@DataStax/instagram-engineerings-3-rules-to-a-scalable-cloud-application-architecture-c44afed31406)
5. [Simplicity by Distributing Complexity](https://jobs.zalando.com/tech/blog/simplicity-by-distributing-complexity/)
6. [Why Over-Reusing is Bad](http://tech.transferwise.com/why-over-reusing-is-bad/)
7. [Avoid Over Engineering](https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8)